## 自我介绍
SJTU 硕士
网络空间安全
数据结构、操作系统、计算机网络
项目经历
加速器 运行在PC的软件，连接加速服务器，作为网关将局域网的主机游戏的数据包转发到加速服务器，完成加速
手势密码 通过录制用户输入图案密码的视频，获取视频中用户手部的运动，还原密码，使用python实现

## C++
### C++ 是什么？
以C语言为基础，开发的一种面向对象的语言
支持面向对象编程、泛型编程和过程化编程
常用于系统开发，引擎开发等
支持类：类、封装、重载等特性

### 与C语言区别
C 面向过程 结构化语言 直接访问内存 硬件编程 效率高移植性好
C++ 兼容面向过程 面向对象（struct public） 继承多态 泛型编程 STL

### extern 关键字
extern C 链接C库的函数 因为重载，C++会编译翻译成函数名+形参，在C库中找不到
extern 在其他模块寻找定义
与static对比 static存在静态区，声明时定义， 只在模块中生效， 不与extern连用
与const 与extern连用来声明该常量可以作用于其他编译模块中

### static 关键字
局部 变静态，改变存储位置，声明周期同程序
全局 函数 不改位置，不能被其他模块链接
静态函数 只有一个实例 
类的静态成员变量在类实例化之前就已经存在了，并且分配了内存。
static 成员只能类外初始化
可以通过类名访问（无对象生成时亦可），也可以通过对象访问

### const 关键字
修饰类的成员变量，表示成员常量，不能被修改。
修饰函数 承诺不修改类内数据成员 不调用其他非const
使用const构成重载
类外定义const成员函数 声明和定义都要const

### volitale关键字
它用来解决变量在共享环境下容易出现读取错误的问题。
volitale 是拒绝编译器的优化，直接从内存读取数据的关键字。
使用实例：中断程序访问到的变量；多线程多任务共享的变量。

### explicit关键字
阻止隐式的类型转换

### 封装
封装是实现面向对象程序设计的第一步，封装就是将数据或函数等集合在一个个的类中
封装的意义在于保护或者防止代码（数据）被我们无意中破坏。

### 继承
继承主要实现重用代码，节省开发时间。
子类可以继承父类的一些东西。

### 多态
函数过程 多种输入 不同结果
不同对象 相同输入 不同结果
指向基类的指针，来调用实现派生类中的方法。
每一个对象内部都有一个虚表指针，该虚表指针被初始化为本类的虚表。所以在程序中，不管你的对象类型如何转换，但该对象内部的虚表指针是固定的，所以呢，才能实现动态的对象函数调用，这就是C++多态性实现的原理。
子类继承父类大部分的资源，不能继承的有构造函数，析构函数，拷贝构造函数，operator=函数，友元函数等等

### 静态关联与动态关联
关联：确定调用的具体对象的过程。（指把一个函数名和一个类对象捆绑在一起，建立关联）。
静态关联：在编译时即可确定其调用的虚函数属于哪一个类，例如函数重载和通过对象名调用的虚函数。
动态关联：编译系统把他放在运行阶段进行处理，在运行阶段确定关联关系。

### 智能指针
智能指针是一个存储指向动态分配（堆）对象指针的类，构造函数传入普通指针，析构函数释放指针。栈上分配，函数或程序结束自动释放，防止内存泄露。
unique_ptr， 独占所指对象，不支持复制和赋值，直接赋值会编译出错。
shared_ptr， 允许多个指针指向同个对象，基于引用计数的智能指针。可随意赋值，直到内存的引用计数为0的时候这个内存会被释放。
weak_ptr, 指向shared_ptr,管理

智能指针的循环引用怎么回事？如何解决？
两个指针相互指向对方，析构时由于引用计数不为0导致内存泄漏。
方法：采用弱引用的weak_ptr即可。弱引用当引用的对象活着的时候不一定存在。仅仅是当它存在的时候的一个引用。弱引用并不修改该对象的引用计数，这意味这弱引用它并不对对象的内存进行管理，在功能上类似于普通指针，然而一个比较大的区别是，弱引用能检测到所管理的对象是否已经被释放，从而避免访问非法内存。
智能指针是线程安全的吗？
shared_ptr 本身不是 100% 线程安全的。它的引用计数本身是安全且无锁的，但对象的读写则不是

### 多重继承
一个派生类有两个或多个基类class D:public A,private B,protected C
二义性：基类同名成员（限定符）、基类派生类同名成员（同名覆盖）、多基类继承同基类（看不到爷爷）
虚继承，间接基类中的成员只会保留一份

### 赋值构造和拷贝构造
一般如果构造函数中存在动态内存分配，则必须定义拷贝构造函数。否则，可能会导致两个对象成员指向同一地址，出现“指针悬挂问题”。

### 析构函数可以抛出异常吗？
C++标准指明析构函数不能、也不应该抛出异常。
如果析构函数抛出异常，则异常点之后的程序不会执行，如果析构函数在异常点之后执行了某些必要的动作比如释放某些资源，则这些动作不会执行，会造成诸如资源泄漏的问题。
通常异常发生时，c++的机制会调用已经构造对象的析构函数来释放资源，此时若析构函数本身也抛出异常，则前一个异常尚未处理，又有新的异常，会造成程序崩溃的问题。

### 不能是虚函数
普通函数只能重载，不能被重写，因此编译器会在编译时绑定函数。
构造函数是知道全部信息才能创建对象，然而虚函数允许只知道部分信息。
内联函数在编译时被展开，虚函数在运行时才能动态绑定函数。
友元函数 因为不可以被继承。
静态成员函数 只有一个实体，不能被继承。父类和子类共有。

### 内联与宏
内联函数是用来消除函数调用时的时间开销。频繁被调用的短小函数非常受益。
A. 宏定义不检查函数参数，返回值什么的，只是展开，相对来说，内联函数会检查参数类型，所以更安全。
B. 宏是由预处理器对宏进行替代，而内联函数是通过编译器控制来实现的

### 设计模式
反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结

单例模式 一个类只有一个实例 一个全局访问点
```C++

class Singleton
{
protected:
    Singleton(const string value): value_(value){}
    static Singleton* singleton_;
    string value_;

public:
    Singleton(Singleton &other) = delete;
    void operator=(const Singleton &) = delete;
    static Singleton *GetInstance(const string& value);
    string value() const{    return value_;} 
};

Singleton* Singleton::singleton_= nullptr;;
Singleton *Singleton::GetInstance(const string& value)
{ if(singleton_==nullptr){singleton_ = new Singleton(value);}
    return singleton_;
    }
```

工厂模式 定义一个用于创建对象的接口，让子类决定实例化哪一个类
```C++
class Product {
 public:
  virtual ~Product() {}
  virtual string Operation() const = 0;
};

class ConcreteProduct1 : public Product {
 public:
  std::string Operation() const override {
    return "{Result of the ConcreteProduct1}";
  }
};
class ConcreteProduct2 : public Product {
 public:
  std::string Operation() const override {
    return "{Result of the ConcreteProduct2}";
  }
};

class Creator {
 public:
  virtual ~Creator(){};
  virtual Product* FactoryMethod() const = 0;

  string SomeOperation() const {
    Product* product = this->FactoryMethod();
    string result = "Creator: The same creator's code has just worked with " + product->Operation();
    delete product;
    return result;
  }
};

class ConcreteCreator1 : public Creator {
 public:
  Product* FactoryMethod() const override {
    return new ConcreteProduct1();
  }
};

class ConcreteCreator2 : public Creator {
 public:
  Product* FactoryMethod() const override {
    return new ConcreteProduct2();
  }
};
```

### STL
容器和算法
序列式容器：vector、list、deque、stack、queue、heap、priority_queue
关联式容器，内部结构基本上是一颗平衡二叉树：set、map、multiset、multimap
set：其内部元素会根据元素的键值自动被排序。区别于map，它的键值就是实值，而map可以同时拥有不同的键值和实值。

### vector中erase()和remove()的区别？
erase函数可以用于删除vector容器中的一个或者一段元素。在进行单个元素删除后，传入的迭代器指向不变，仍然指向被删除元素的位置。
vector中remove的作用是将范围内为val的值都remove到后面，返回新的end()值（非val部分的end）,但传入的原vector的end并没有发生改变，因此size也就没有变化。

### 指针和引用
1. 指针是一个变量，只不过这个变量存储的是一个地址，指向内存的一个存储单元；而引用仅是个别名；
2. 引用使用时无需解引用(*)，指针需要解引用；
3. 引用只能在定义时被初始化一次，之后不可变；指针可变；
4. 引用没有 const，指针有 const；
5. 引用不能为空，指针可以为空；
6. “sizeof 引用”得到的是所指向的变量(对象)的大小，而“sizeof 指针”得到的是指针本身的大小；
7. 指针和引用的自增(++)运算意义不一样；
8. 指针可以有多级，但是引用只能是一级（int **p；合法 而 int &&a是不合法的）
9. 从内存分配上看：程序为指针变量分配内存区域，而引用不需要分配内存区域。

### 内存泄露
用动态存储分配函数动态开辟的空间，在使用完毕后未释放，结果导致一直占据该内存单元即为内存泄露。
使用的时候要记得分配的长度。
malloc的时候得确定在那里free.
对指针赋值的时候应该注意被赋值指针需要不需要释放.
动态分配内存的指针最好不要再次赋值.

### 静态动态内存分配
静态内存分配是在编译时完成的，不占用CPU资源；动态分配内存运行时完成，分配与释放需要占用CPU资源；
静态内存分配是在栈上分配的，动态内存是堆上分配的，malloc函数；

### new和malloc的区别
1. malloc与free是C++/C语言的标准库函数，new/delete是C++的运算符。它们都可用于申请动态内存和释放内存。
2. 对于非内部数据类型的对象而言，光用maloc/free无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。
3. 由于malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于malloc/free。因此C++语言需要一个能完成动态内存分配和初始化工作的运算符new，以一个能完成清理与释放内存工作的运算符delete。注意new/delete不是库函数。
4. C++程序经常要调用C函数，而C程序只能用malloc/free管理动态内存。
5. new可以认为是malloc加构造函数的执行。new出来的指针是直接带类型信息的。而malloc返回的都是void指针。

### delete[] 数组
new的前四个字节存储了数组的长度,对数组对象逐一析构

### TCP UDP
1. TCP面向连接， UDP无连接的
2. TCP有保障的，UDP传输无保障的
3. TCP是效率低的首部20，UDP效率高首部
4. TCP是基于流的，UDP基于数据报文
5. TCP传输重要数据，UDP传输不重要的数据

### 程序内存
1.栈 - 由编译器自动分配释放
2.堆 - 一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收
3.全局区(静态区)，全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，
未初始化的在相邻的另一块区域。- 程序结束释放    
4.另外还有一个专门放常量的地方。- 程序结束释放
5 程序代码区，存放2进制代码。
在函数体中定义的变量通常是在栈上，用malloc， calloc， realloc等分配内存的函数分配得到的就是在堆上。在所有函数体外定义的是全局量，加了static修饰符后不管在哪里都存放在全局区(静态区)，在所有函数体外定义的static变量表示在该文件中有效，不能extern到别的文件用，在函数体内定义的static表示只在该函数体内有效。另外，函数中的"adgfdf"这样的字符串存放在常量区。

