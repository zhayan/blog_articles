## 自我介绍
SJTU 硕士
网络空间安全
数据结构、操作系统、计算机网络
项目经历
加速器 运行在PC的软件，连接加速服务器，作为网关将局域网的主机游戏的数据包转发到加速服务器，完成加速
手势密码 通过录制用户输入图案密码的视频，获取视频中用户手部的运动，还原密码，使用python实现

## C++
### C++ 是什么？
以C语言为基础，开发的一种面向对象的语言
支持面向对象编程、泛型编程和过程化编程
常用于系统开发，引擎开发等
支持类：类、封装、重载等特性

### 与C语言区别
C 面向过程 结构化语言 直接访问内存 硬件编程 效率高移植性好
C++ 兼容面向过程 面向对象（struct public） 继承多态 泛型编程 STL

### extern 关键字
extern C 链接C库的函数 因为重载，C++会编译翻译成函数名+形参，在C库中找不到
extern 在其他模块寻找定义
与static对比 static存在静态区，声明时定义， 只在模块中生效， 不与extern连用
与const 与extern连用来声明该常量可以作用于其他编译模块中

### static 关键字
局部 变静态，改变存储位置，声明周期同程序
全局 函数 不改位置，不能被其他模块链接
静态函数 只有一个实例 
类的静态成员变量在类实例化之前就已经存在了，并且分配了内存。
static 成员只能类外初始化
可以通过类名访问（无对象生成时亦可），也可以通过对象访问

### const 关键字
修饰类的成员变量，表示成员常量，不能被修改。
修饰函数 承诺不修改类内数据成员 不调用其他非const
使用const构成重载
类外定义const成员函数 声明和定义都要const

### volitale关键字
它用来解决变量在共享环境下容易出现读取错误的问题。
volitale 是拒绝编译器的优化，直接从内存读取数据的关键字。
使用实例：中断程序访问到的变量；多线程多任务共享的变量。

### explicit关键字
阻止隐式的类型转换

### 封装
封装是实现面向对象程序设计的第一步，封装就是将数据或函数等集合在一个个的类中
封装的意义在于保护或者防止代码（数据）被我们无意中破坏。

### 继承
继承主要实现重用代码，节省开发时间。
子类可以继承父类的一些东西。

### 多态
函数过程 多种输入 不同结果
不同对象 相同输入 不同结果
指向基类的指针，来调用实现派生类中的方法。
每一个对象内部都有一个虚表指针，该虚表指针被初始化为本类的虚表。所以在程序中，不管你的对象类型如何转换，但该对象内部的虚表指针是固定的，所以呢，才能实现动态的对象函数调用，这就是C++多态性实现的原理。
子类继承父类大部分的资源，不能继承的有构造函数，析构函数，拷贝构造函数，operator=函数，友元函数等等

### 静态关联与动态关联
关联：确定调用的具体对象的过程。（指把一个函数名和一个类对象捆绑在一起，建立关联）。
静态关联：在编译时即可确定其调用的虚函数属于哪一个类，例如函数重载和通过对象名调用的虚函数。
动态关联：编译系统把他放在运行阶段进行处理，在运行阶段确定关联关系。

### 智能指针
智能指针是一个存储指向动态分配（堆）对象指针的类，构造函数传入普通指针，析构函数释放指针。栈上分配，函数或程序结束自动释放，防止内存泄露。
unique_ptr， 独占所指对象，不支持复制和赋值，直接赋值会编译出错。
shared_ptr， 允许多个指针指向同个对象，基于引用计数的智能指针。可随意赋值，直到内存的引用计数为0的时候这个内存会被释放。
weak_ptr, 指向shared_ptr,管理

构造函数中计数初始化为1；
拷贝构造函数中计数值加1；
赋值运算符中，左边的对象引用计数减一，右边的对象引用计数加一；
析构函数中引用计数减一；
在赋值运算符和析构函数中，如果减一后为0，则调用delete释放对象。
share_prt与weak_ptr的区别？

智能指针的循环引用怎么回事？如何解决？
两个指针相互指向对方，析构时由于引用计数不为0导致内存泄漏。
方法：采用弱引用的weak_ptr即可。弱引用当引用的对象活着的时候不一定存在。仅仅是当它存在的时候的一个引用。弱引用并不修改该对象的引用计数，这意味这弱引用它并不对对象的内存进行管理，在功能上类似于普通指针，然而一个比较大的区别是，弱引用能检测到所管理的对象是否已经被释放，从而避免访问非法内存。
智能指针是线程安全的吗？
shared_ptr 本身不是 100% 线程安全的。它的引用计数本身是安全且无锁的，但对象的读写则不是

### 多重继承
一个派生类有两个或多个基类class D:public A,private B,protected C
二义性：基类同名成员（限定符）、基类派生类同名成员（同名覆盖）、多基类继承同基类（看不到爷爷）
虚继承，间接基类中的成员只会保留一份

### 赋值构造和拷贝构造
一般如果构造函数中存在动态内存分配，则必须定义拷贝构造函数。否则，可能会导致两个对象成员指向同一地址，出现“指针悬挂问题”。

### 必须在构造函数初始化列表的
1，常量成员
常量成员只能初始化不能赋值，所以必须放在初始化列表里。
2，引用类型
引用必须在定义时初始化，并且不能重新赋值，所以必须放在初始化表里。
3，对象成员

### 析构函数可以抛出异常吗？
C++标准指明析构函数不能、也不应该抛出异常。
如果析构函数抛出异常，则异常点之后的程序不会执行，如果析构函数在异常点之后执行了某些必要的动作比如释放某些资源，则这些动作不会执行，会造成诸如资源泄漏的问题。
通常异常发生时，c++的机制会调用已经构造对象的析构函数来释放资源，此时若析构函数本身也抛出异常，则前一个异常尚未处理，又有新的异常，会造成程序崩溃的问题。

### 不能是虚函数
普通函数只能重载，不能被重写，因此编译器会在编译时绑定函数。
构造函数是知道全部信息才能创建对象，然而虚函数允许只知道部分信息。
内联函数在编译时被展开，虚函数在运行时才能动态绑定函数。
友元函数 因为不可以被继承。
静态成员函数 只有一个实体，不能被继承。父类和子类共有。

### C++四种类型转换
 const_cast 转换成非常量
 static_cast 强制转换，基类和派生类之间指针或引用的转换
 dynamic_cast与编译器的属性设置有关
 reinterpret_cast是强制类型转换符用来处理无关类型转换的，通常为操作数的位模式提供较低层次的重新解释

### 内存对齐
以结构体最宽的类型倍数

### 内联与宏
内联函数是用来消除函数调用时的时间开销。频繁被调用的短小函数非常受益。
A. 宏定义不检查函数参数，返回值什么的，只是展开，相对来说，内联函数会检查参数类型，所以更安全。
B. 宏是由预处理器对宏进行替代，而内联函数是通过编译器控制来实现的

### 设计模式
反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结

单例模式 一个类只有一个实例 一个全局访问点
```C++

class Singleton
{
protected:
    Singleton(const string value): value_(value){}
    static Singleton* singleton_;
    string value_;

public:
    Singleton(Singleton &other) = delete;
    void operator=(const Singleton &) = delete;
    static Singleton *GetInstance(const string& value);
    string value() const{    return value_;} 
};

Singleton* Singleton::singleton_= nullptr;;
Singleton *Singleton::GetInstance(const string& value)
{ if(singleton_==nullptr){singleton_ = new Singleton(value);}
    return singleton_;
    }
```

工厂模式 定义一个用于创建对象的接口，让子类决定实例化哪一个类
```C++
class Product {
 public:
  virtual ~Product() {}
  virtual string Operation() const = 0;
};

class ConcreteProduct1 : public Product {
 public:
  string Operation() const override {
    return "{Result of the ConcreteProduct1}";
  }
};
class ConcreteProduct2 : public Product {
 public:
  string Operation() const override {
    return "{Result of the ConcreteProduct2}";
  }
};

class Creator {
 public:
  virtual ~Creator(){};
  virtual Product* FactoryMethod() const = 0;

  string SomeOperation() const {
    Product* product = this->FactoryMethod();
    string result = "Creator: The same creator's code has just worked with " + product->Operation();
    delete product;
    return result;
  }
};

class ConcreteCreator1 : public Creator {
 public:
  Product* FactoryMethod() const override {
    return new ConcreteProduct1();
  }
};

class ConcreteCreator2 : public Creator {
 public:
  Product* FactoryMethod() const override {
    return new ConcreteProduct2();
  }
};
```

### STL
容器和算法
序列式容器：vector、list、deque、stack、queue、heap、priority_queue
关联式容器，内部结构基本上是一颗平衡二叉树：set、map、multiset、multimap
set：其内部元素会根据元素的键值自动被排序。区别于map，它的键值就是实值，而map可以同时拥有不同的键值和实值。

### RB-tree特点
每个节点或者是黑色，或者是红色。
根节点是黑色。
每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]
如果一个节点是红色的，则它的子节点必须是黑色的。
从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。

### 栈和队列都
一种逻辑的结构，具体实现用链表和数组都可以。
栈的特点是先进后出，栈的数据访问很严格，只能访问最后加入的数据，这对数据访问控制严格的应用很有好处。应用中，如字符串倒序输出，运算符的匹配，使用栈的原理就可以很好的实现。程序函数的调用就是使用的栈，完成函数后返回到栈顶指针执行。
队列的特点是先进先出，数据从队列尾插入，从队列头读取，可以模拟很多现实的生产环境，例如排队，不允许有任何元素插队，常用于生产消费模型，队列有产品，通知消费者来消费，无产品通知生产者生产。


### vector中erase()和remove()的区别？
erase函数可以用于删除vector容器中的一个或者一段元素。在进行单个元素删除后，传入的迭代器指向不变，仍然指向被删除元素的位置。
vector中remove的作用是将范围内为val的值都remove到后面，返回新的end()值（非val部分的end）,但传入的原vector的end并没有发生改变，因此size也就没有变化。

### 指针和引用
1. 指针是一个变量，只不过这个变量存储的是一个地址，指向内存的一个存储单元；而引用仅是个别名；
2. 引用使用时无需解引用(*)，指针需要解引用；
3. 引用只能在定义时被初始化一次，之后不可变；指针可变；
4. 引用没有 const，指针有 const；
5. 引用不能为空，指针可以为空；
6. “sizeof 引用”得到的是所指向的变量(对象)的大小，而“sizeof 指针”得到的是指针本身的大小；
7. 指针和引用的自增(++)运算意义不一样；
8. 指针可以有多级，但是引用只能是一级（int **p；合法 而 int &&a是不合法的）
9. 从内存分配上看：程序为指针变量分配内存区域，而引用不需要分配内存区域。

### 内存泄露
用动态存储分配函数动态开辟的空间，在使用完毕后未释放，结果导致一直占据该内存单元即为内存泄露。
使用的时候要记得分配的长度。
malloc的时候得确定在那里free.
对指针赋值的时候应该注意被赋值指针需要不需要释放.
动态分配内存的指针最好不要再次赋值.
(1)在windows平台下通过CRT中的库函数进行检测；
(2)在可能泄漏的调用前后生成块的快照，比较前后的状态，定位泄漏的位置
(3)Linux下通过工具valgrind检测

### 静态动态内存分配
静态内存分配是在编译时完成的，不占用CPU资源；动态分配内存运行时完成，分配与释放需要占用CPU资源；
静态内存分配是在栈上分配的，动态内存是堆上分配的，malloc函数；

### new和malloc的区别
1. malloc与free是C++/C语言的标准库函数，new/delete是C++的运算符。它们都可用于申请动态内存和释放内存。
2. 对于非内部数据类型的对象而言，光用maloc/free无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。
3. 由于malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于malloc/free。因此C++语言需要一个能完成动态内存分配和初始化工作的运算符new，以一个能完成清理与释放内存工作的运算符delete。注意new/delete不是库函数。
4. C++程序经常要调用C函数，而C程序只能用malloc/free管理动态内存。
5. new可以认为是malloc加构造函数的执行。new出来的指针是直接带类型信息的。而malloc返回的都是void指针。

### delete[] 数组
new的前四个字节存储了数组的长度,对数组对象逐一析构

### TCP UDP
1. TCP面向连接， UDP无连接的
2. TCP有保障的，UDP传输无保障的
3. TCP是效率低的首部20，UDP效率高首部8
4. TCP是基于流的，UDP基于数据报文
5. TCP传输重要数据，UDP传输不重要的数据
TCP SMTP TELNET HTTP FTP
UDP DNS NFS TFTP

### Nagle算法
等待服务器应答包到达后，再发送下一个数据包。数据在发送端被缓存，如果缓存到达指定大小就将其发送，或者上一个数据的应答包到达，将缓存区一次性全部发送。。

### Socket编程

TCP s:socket(family,,protocol) bind(fd,ipport) listen() accept()阻塞 write() read() send() recv() c:socket() connect()阻塞 rw() close()
UDP s:socket() bind() sendto() recvfrom() c:socket() sendto() recvfrom()  close() connect()

### IO多路复用
epoll和select的区别？
select在一个进程中打开的最大fd是有限制的，由FD_SETSIZE设置，默认值是2048。不过 epoll则没有这个限制，内存越大，fd上限越大，1G内存都能达到大约10w左右。
select的轮询机制是系统会去查找每个fd是否数据已准备好，当fd很多的时候，效率当然就直线下降了，epoll采用基于事件的通知方式，一旦某个fd数据就绪时，内核会采用类似callback的回调机制，迅速激活这个文件描述符，高效。
select还是epoll都需要内核把FD消息通知给用户空间，epoll是通过内核于用户空间mmap同一块内存实现的，而select则做了不必要的拷贝
select底层是数组，poll是链表，epoll是红黑树

epoll的工作模式
LT(level triggered) 是缺省的工作方式，并且同时支持block和no-block socket。在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你的，所以，这种模式编程出错误可能性要小一点。传统的select/poll都是这种模型的代表。
ET (edge-triggered) 是高速工作方式，只支持no-block socket。 在这种模式下，当描述符从未就绪变为就绪时，内核就通过epoll告诉你，然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作而导致那个文件描述符不再是就绪状态。不过在TCP协议中，ET模式的加速效用仍需要更多的benchmark确认。

### TCP重传
超时重传（RTO）
当一个包被发送后，就开启一个定时器，如果定时时间到了，还未收到能确认该发送包的应答包，就重传一份数据。注意收到的应答包可能是该包也可能是后面包的，但是只要能确认该包被收到就行。另外如果，是因为网络延时造成重传，则接受端收到重复数据包后丢弃该包。
快速重传
当如果发送端收到一个包的三次应答包后，立即重传，比超时重传更高效。

### TCP拥塞控制
滑动窗口
慢启动算法（工作过程如下图所示）：设置初始拥塞窗口大小为1，以后每收到一个应答拥塞窗口大小就加1，窗口大小呈指数级增长。客户端可发送数据的取拥塞窗口和应答包窗口两者中较小的那个。
此时设置一个“慢启动阈值”，它的值是当前拥塞窗口大小的一半。
超时后重新慢启动，到阈值线性增加，再超时再设置阈值，快速恢复，窗口是之前超时的一半

### 坚持定时器
TCP不对ACK应答报文进行确认，如果接受端缓冲被占满，发送一个窗口为0的应答，过了一段时间数据处理完毕，重新发送一个应答，告诉发送端窗口大小。不幸的是，如果这个包丢了，就会进入死锁状态——发送端等待更新窗口的应答包，接收端等待接收数据。
为了避免死锁了发生，TCP使用了一个坚持定时器来周期性地向接收方查询，以便发现窗口是否已经增大。这一过程也被称为窗口探查。

### http
http数据由请求行，首部字段，空行，报文主体四个部分组成
首部字段分为：通用首部字段，请求首部字段，响应首部字段，实体首部字段
200 - 请求成功
301 - 资源（网页等）被永久转移到其它URL.
404 - 请求的资源（网页等）不存在
500 - 内部服务器错误
1xx：指示信息--表示请求已接收，继续处理
2xx：成功--表示请求已被成功接收、理解、接受
3xx：重定向--要完成请求必须进行更进一步的操作
4xx：客户端错误--请求有语法错误或请求无法实现
5xx：服务器端错误--服务器未能实现合法的请求

HTTP 1.0规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接，服务器不跟踪每个客户也不记录过去的请求。连接无法复用
HTTP 1.1支持持久连接，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟。
HTTP2.0 多路复用 (Multiplexing)同时通过单一的 HTTP/2 连接发起多重的请求-响应消息。
服务端推送（Server Push）

GET 请求获取Request-URI所标识的资源
POST 在Request-URI所标识的资源后附加新的数据
PUT 请求服务器存储一个资源，并用Request-URI作为其标识
DELETE 请求服务器删除Request-URI所标识的资源

GET 用于获取信息，是无副作用的，是幂等的，且可缓存
POST 用于修改服务器上的数据，有副作用，非幂等，不可缓存

### https
1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。
2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。
3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全

### Cookie的缺陷
cookie会被附加在每个HTTP请求中，所以无形中增加了流量。
由于在HTTP请求中的cookie是明文传递的，所以安全性成问题。(除非用HTTPS)
Cookie的大小限制在4KB左右。对于复杂的存储需求来说是不够用的。


### 程序内存
1.栈 - 由编译器自动分配释放
2.堆 - 一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收
3.全局区(静态区)，全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，
未初始化的在相邻的另一块区域。- 程序结束释放    
4.另外还有一个专门放常量的地方。- 程序结束释放
5 程序代码区，存放2进制代码。
在函数体中定义的变量通常是在栈上，用malloc， calloc， realloc等分配内存的函数分配得到的就是在堆上。在所有函数体外定义的是全局量，加了static修饰符后不管在哪里都存放在全局区(静态区)，在所有函数体外定义的static变量表示在该文件中有效，不能extern到别的文件用，在函数体内定义的static表示只在该函数体内有效。另外，函数中的"adgfdf"这样的字符串存放在常量区。

### Copy-on-write
如果有多个调用者（callers）同时请求相同资源（如内存或磁盘上的数据存储），他们会共同获取相同的指针指向相同的资源，直到某个调用者试图修改资源的内容时，系统才会真正复制一份专用副本（private copy）给该调用者，而其他调用者所见到的最初的资源仍然保持不变。

### 常用sql
SELECT * FROM * WHERE/HAVING BETWEEN LIKE IN GROUP BY ORDER BY
JOIN INNER JOIN/LEFT OUTER JOIN 
嵌套查询

### 三大范式：
每一项都是不可分割的原子项
非码属性必须完全依赖于候选码，如果不是需要分表
非主属性不可依赖于其他非主属性。（不可传递依赖主属性）

### b+树相比于b树的查询优势：
b+树的中间节点不保存数据，所以磁盘页能容纳更多节点元素，更“矮胖”；
b+树查询必须查找到叶子节点，b树只要匹配到即可不用管元素位置，因此b+树查找更稳定（并不慢）；
对于范围查找来说，b+树只需遍历叶子节点链表即可，b树却需要重复地中序遍历

### 事务的四个隔离等级和解决的问题。
读未提交（脏读）读已提交（不可重复读）可重复读（幻读）串行化
读提交，就是一个事务要等另一个事务提交后才能读取数据。
重复读，就是在开始读取数据（事务开启）时，不再允许修改操作。
串行化，是最高的事务隔离级别，在该级别下，事务串行化顺序执行。

### 数据库引擎
Innodb 支持事务处理与外键和行级锁。而MyISAM不支持。
这种把多条语句作为一个整体进行操作的功能，被称为数据库事务。
InnoDB：
支持事务处理等
不加锁读取
支持外键
支持行锁
不支持FULLTEXT类型的索引
不保存表的具体行数，扫描表来计算有多少行
DELETE 表时，是一行一行的删除
InnoDB 把数据和索引存放在表空间里面
跨平台可直接拷贝使用
InnoDB中必须包含AUTO_INCREMENT类型字段的索引
表格很难被压缩

MyISAM：
不支持事务，回滚将造成不完全回滚，不具有原子性
不支持外键
支持全文搜索
保存表的具体行数,不带where时，直接返回保存的行数
DELETE 表时，先drop表，然后重建表
MyISAM 表被存放在三个文件 。frm 文件存放表格定义。 数据文件是MYD (MYData) 。 索引文件是MYI (MYIndex)引伸
跨平台很难直接拷贝
MyISAM中可以使AUTO_INCREMENT类型字段建立联合索引
表格可以被压缩

选择：
因为MyISAM相对简单所以在效率上要优于InnoDB.如果系统读多，写少。对原子性要求低。那么MyISAM最好的选择。且MyISAM恢复速度快。可直接用备份覆盖恢复。
如果系统读少，写多的时候，尤其是并发写入高的时候。InnoDB就是首选了。


### 数据库索引
聚集索引，该索引中键值的逻辑顺序决定了表中相应行的物理顺序。
非聚集索引，该索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同。

唯一索引
在设计关系数据表的时候，看上去唯一的列，例如身份证号、邮箱地址等，因为他们具有业务含义，因此不宜作为主键。

### 为什么使用redis？
考虑性能和并发。
性能上：我们在碰到需要执行耗时特别久，且结果不频繁变动的SQL，就特别适合将运行结果放入缓存。Redis基于内存级别的缓存。
并发上：高并发下优先访问redis数据，避免直接访问数据库
支持的数据类型

string，hash（登录存储用户信息），list（消息队列），set，sorted set

### redis存在哪些问题
缓存和数据库双写一致性：先更新数据库，再删缓存。如果项目要去强一致性，则不能使用缓存。
缓存雪崩：双缓存；缓存失效时间加上随机值，避免集体雪崩
缓存击穿：异步更新；互斥锁；过滤非法key
缓存并发竞争：锁；串行控制

### 单线程redis性能快的原因
纯内存操作
单线程操作，避免了频繁的上下文切换
采用了非阻塞I/O多路复用机制

### redis的过期策略以及内存淘汰机制
redis采用的是定期删除+惰性删除策略。
为什么不用定时删除策略?
定时删除,用一个定时器来负责监视key,过期则自动删除。虽然内存及时释放，但是十分消耗CPU资源。在大并发请求下，CPU要将时间应用在处理请求，而不是删除key。
定期删除+惰性删除是如何工作的呢?
定期删除，redis默认每个100ms检查，是否有过期的key,有过期key则删除。需要说明的是，redis不是每个100ms将所有的key检查一次，而是随机抽取进行检查(如果每隔100ms,全部key进行检查，redis岂不是卡死)。因此，如果只采用定期删除策略，会导致很多key到时间没有删除。

于是，惰性删除派上用场。也就是说在你获取某个key的时候，redis会检查一下，这个key如果设置了过期时间那么是否过期了？如果过期了此时就会删除。

采用定期删除+惰性删除就没其他问题了么?
如果定期删除没删除key。然后你也没即时去请求key，也就是说惰性删除也没生效。这样，redis的内存会越来越高。那么就应该采用内存淘汰机制。
当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。

### 进程间通信方式
信号量：信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。
管道( pipe )：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。
命名管道 (named pipe) ： 有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。
消息队列( message queue ) ： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。
信号 ( sinal ) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。
共享内存( shared memory ) ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。
套接字( socket ) ： 套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。

### 多线程和多进程的区别
进程数据是分开的:共享复杂，需要用IPC，同步简单；多线程共享进程数据：共享简单，同步复杂
进程创建销毁、切换复杂，速度慢 ；线程创建销毁、切换简单，速度快
进程占用内存多， CPU利用率低；线程占用内存少， CPU利用率高
进程间不会相互影响 ；进程一个线程挂掉将导致整个进程挂掉
线程所私有的：线程id、寄存器的值、栈、线程的优先级和调度策略、线程的私有数据、信号屏蔽字、errno变量

协程看上去也是子程序，但执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行。

### 线程池了解吗
目的是减少线程创建和销毁的开销，以及减少线程创建的数目
提交一个任务到线程池中，线程池的处理流程如下：
判断线程池里的核心线程是否都在执行任务，如果不是（核心线程空闲或者还有核心线程没有被创建）则创建一个新的工作线程来执行任务。如果核心线程都在执行任务，则进入下个流程。
线程池判断工作队列是否已满，如果工作队列没有满，则将新提交的任务存储在这个工作队列里。如果工作队列满了，则进入下个流程。
判断线程池里的线程是否都处于工作状态，如果没有，则创建一个新的工作线程来执行任务。如果已经满了，则交给饱和策略来处理这个任务。

### 多线程同步和互斥
信号量：对应一个down和up操作，down使信号量减1，up使信号量加1，如果信号量大于0，则down后继续执行，如果down等于0，则down后睡眠，但是并不会将信号量减到负数。down和up都是原子操作
互斥量：互斥量是信号量的一种特例，他只有0和1两种状态（解锁和加锁）。
关键区域：关键区域与互斥量类似，但是最大的区别在于，关键区域会进行忙等待，而互斥量如果不能解锁会自动让出CPU

Windows平台下
关键区域（Critical Section）：关键节不是内核对象，在用户态实现了同一进程中线程的互斥。由于使用时不需要从用户态切换到核心态，所以速度很快（X86系统上约为20个指令周期），但其缺点是不能跨进程同步，同时不能指定阻塞时的等待时间，只能无限等待。
互斥体（Mutex）：互斥体实现了和关键节类似的互斥功能，但区别在于：互斥体是内核对象，可以实现跨进程互斥，但需要在用户态和核心态之间切换，速度比关键节慢得多（X86系统上约为600个指令周期），同时可以指定阻塞时的等待时间。
事件（Event）：事件也是内核对象，具有“信号态”和“无信号态”两种状态。当某一线程等待一个事件时，如果事件为信号态，将继续执行，如果事件为无信号态，那么线程被阻塞。线程能够指定阻塞时的等待时间。
信号量（Semaphore）：信号量是一个资源计数器，当某线程获取某信号量时，信号量计数首先减1，如果计数小于0，那么该线程被阻塞；当某线程释放某信号量时，信号量计数首先加1，如果计数小于或等与0，那么唤醒某被阻塞的线程并执行之。

Linux平台下（加锁）
互斥锁
读写锁
自旋锁
屏障

死锁就是几个进程申请资源，出现了循环等待的情况

避免死锁的方法：
资源是互斥的 ；不可抢占 ；占有且申请；动态检查系统安全性
忽略该问题；检测死锁并恢复；仔细分配资源，动态避免死锁；破坏死锁发生条件，避免死锁

### 内核信号通知
内核给进程发送信号，是在进程所在的进程表项的信号域设置对应的信号的位。进程处理信号的时机就是从内核态即将返回用户态的时候。
执行用户自定义的信号处理函数的方法很巧妙。把该函数的地址放在用户栈栈顶，进程从内核返回到用户态的时候，先弹出信号处理函数地址，于是就去执行信号处理函数了，然后再弹出，才是返回进入内核时的状态。

### 虚拟内存
操作系统为了管理内存，给每个进程都分配独立的地址空间，对32位的系统而言，这个空间的大小是4GB。这4GB并不是实际的物理内存，实际上并不存在，因此有虚拟内存这一名称。
虚拟地址空间被分割成多个大小相同的页面(比如4k为一个页面)，物理地址空间被分割成同样大小的页框
会经过MMU将逻辑地址转换为物理地址，之前说的页表就保存在MMU中，操作系统为每个进程都维护一个页表。

内核空间就将物理内存分为三个区：ZONE_DMA，ZONE_NORMAL，ZONE_HIHGEM。
低端内存的范围上，逻辑地址与物理地址是线性映射的。对于内核空间896M以上剩余的128M是用来访问高端内存的。这128M里的页面到物理页框随机映射的，和用户空间的映射是一样的。低端内存是自动永久映射的，高端内存可以永久映射也可以零时映射。

### 伙伴算法
就是将内存分成若干块，然后尽可能以最适合的方式满足程序内存需求的一种内存管理算法，伙伴算法的一大优势是它能够完全避免外部碎片的产生。
把所有的空闲页框分组为 11 块链表，每一块链表分别包含大小为1，2，4，8，16，32，64，128，256，512 和 1024 个连续的页框。对1024 个页框的最大请求对应着 4MB 大小的连续RAM 块。每一块的第一个页框的物理地址是该块大小的整数倍。例如，大小为 16个页框的块，其起始地址是 16 * 2^12 （2^12 = 4096，这是一个常规页的大小）的倍数。
