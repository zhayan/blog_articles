---
title: 【C++】C++内存管理
date: 2020-12-22 21:08:07
toc: true
tags:
- C++
categories:
- C++
---
参考：https://zhuanlan.zhihu.com/p/51855842

## 为什么要内存对齐
为了减少使用的内存
为了提升数据读取的效率
<!-- more -->

## 内存对齐
对于结构体变量内存对齐遵循以下三个原则：
1. 变量的起始地址能够被其对齐值整除，结构体变量的对齐值为最宽的成员大小。
2. 结构体每个成员相对于起始地址的偏移能够被其自身对齐值整除，如果不能则在前一个成员后面补充字节。
3. 结构体总体大小能够被最宽的成员的大小整除，如不能则在后面补充字节。



## C++程序内存的布局

(代码段或Text Segment)中存放着程序的机器码和只读数据，可执行指令就是从这里取得的。如果可能，系统会安排相同程序的多个运行实体共享这些实例代码。这个段在内存中一般被标记为只读，任何对该区的写操作都会导致段错误（Segmentation Fault）。
Data Segment中存放已初始化的全局或静态变量。
BSS中存放未初始化的全局或静态变量。
Heap(堆)，
Stack(栈)，

1. 栈（Stack） - 由编译器自动分配释放，用来存储函数调用时的临时信息，如函数调用所传递的参数、函数的返回地址、函数的局部变量等。 在程序运行时由编译器在需要的时候分配，在不需要的时候自动清除。栈内存的申请和释放遵循LIFO(先进后出)。

2.堆（Heap） - 一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收，堆的大小并不固定，可动态扩张或缩减。其分配由malloc()、new()等这类实时内存分配函数来实现(brk函数也是从这里分配内存)。

3.全局区/静态区（BSS），全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。- 程序结束释放

4.数据段（Data Segmen）存放已初始化的全局或静态变量。- 程序结束释放

5 代码区（Code Segment），存放着程序的机器码和只读数据，可执行指令就是从这里取得的。如果可能，系统会安排相同程序的多个运行实体共享这些实例代码。这个段在内存中一般被标记为只读，任何对该区的写操作都会导致段错误（Segmentation Fault）。

在函数体中定义的变量通常是在栈上，用malloc， calloc， realloc等分配内存的函数分配得到的就是在堆上。在所有函数体外定义的是全局量，加了static修饰符后不管在哪里都存放在全局区(静态区)，在所有函数体外定义的static变量表示在该文件中有效，不能extern到别的文件用，在函数体内定义的static表示只在该函数体内有效。另外，函数中的"adgfdf"这样的字符串存放在常量区。
