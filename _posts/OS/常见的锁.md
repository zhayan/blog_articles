---
title: 【OS】线程安全的方法
date: 2021-03-17 10:12:48
toc: true
tags:
- 操作系统
categories:
- OS
---
参考：https://zhuanlan.zhihu.com/p/87682798

当多个线程同时操作同一个共享全局变量的时候，就容易出现线程安全问题，由于执行的时序不一样，就会导致主存的值被多个线程修改，会导致安全问题。
锁解决资源占用的问题；保证同一时间一个对象只有一个线程在访问；保证数据的安全性。
<!-- more -->

## 公平锁与非公平锁
公平锁：是指多个线程在等待同一个锁时，必须按照申请锁的先后顺序来一次获得锁。公平锁的好处是，可以保证每个排队的线程都能获得锁，先到先得。但是弊端是，要额外数据保存顺序。
非公平锁：非公平锁不用排队，当锁被释放时，线程抢占锁，可能会造成饥饿问题。

## 互斥锁
从能否有多个线程持有同一把锁的角度划分
互斥锁的概念非常简单，也就是我们常说的同步，即一次最多只能有一个线程持有的锁，当一个线程持有该锁的时候其它线程无法进入上锁的区域。

## 重入锁（递归锁）与 不可重入锁（自旋锁）
从一个线程能否递归获取自己的锁的角度划分
我们知道，一条线程若想进入一个被上锁的区域，首先要判断这个区域的锁是否已经被某条线程所持有。
可重入锁：可以再次获取获得的锁，就是说在释放锁前此线程可以再次进入获取锁的方法 A（方法 A 递归）。
不可重入锁（自旋锁）：不可以再次获取获得的锁，也就是说获得锁进入方法 A 是此线程在释放锁前唯一的一次进入方法 A。

## 悲观锁与乐观锁
悲观锁
悲观锁是就是悲观思想，即认为读少写多，遇到并发写的可能性高，每次去拿数据的时候都认为别人会修改，所以每次在读写数据的时候都会上锁，这样别人想读写这个数据就会 block 直到拿到锁。

乐观锁
乐观锁是一种乐观思想，即认为读多写少，遇到并发写的可能性低，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，采取在写时先读出当前版本号，然后加锁操作（比较跟上一次的版本号，如果一样则更新），如果失败则要重复读。

## 共享锁、排它锁
共享锁和排它锁多用于数据库中的事物操作，主要针对读和写的操作。即一条线程进行读的时候，允许其他线程进入上锁的区域中进行读操作；当一条线程进行写操作的时候，不允许其他线程进入进行任何操作。即读 + 读可以存在，读 + 写、写 + 写均不允许存在

共享锁：也称读锁或 S 锁。如果事务 T 对数据 A 加上共享锁后，则其他事务只能对 A 再加共享锁，不能加排它锁。获准共享锁的事务只能读数据，不能修改数据。
排它锁：也称独占锁、写锁或 X 锁。如果事务 T 对数据 A 加上排它锁后，则其他事务不能再对 A 加任何类型的锁。获得排它锁的事务即能读数据又能修改数据。

## 原子操作
​ 何谓原子性操作，即为最小的操作单元，比如i=1，就是一个原子性操作，这个过程只涉及一个赋值操作。又如i++就不是一个原子操作，它相当于语句i=i+1；这里包括读取i，i+1，结果写入内存三个操作单元。